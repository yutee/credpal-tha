#cloud-config

package_update: true
package_upgrade: true

apt:
  sources:
    docker.list:
      source: "deb [arch=amd64 signed-by=$KEYGATEWAY] https://download.docker.com/linux/ubuntu jammy stable"
      keyid: 7EA0A9C3F273FCD8

packages:
  - nginx
  - certbot
  - python3-certbot-nginx
  - curl
  - git

groups:
  - docker

system_info:
  default_user:
    groups: [docker]

write_files:
  # CHANGE: Bootstrap config (Port 80 only)
  - path: /etc/nginx/sites-available/app
    content: |
      server {
          listen 80;
          server_name ${domain_name};
          location /.well-known/acme-challenge/ {
              root /var/www/html;
          }
          location / {
              proxy_pass http://localhost:3000;
              proxy_set_header Host $host;
          }
      }

  # CHANGE: Template for the FINAL config (Port 443)
  - path: /etc/nginx/sites-available/app.final
    content: |
      server {
          listen 80;
          server_name ${domain_name};
          location /.well-known/acme-challenge/ {
              root /var/www/html;
          }
          location / {
              return 301 https://$host$request_uri;
          }
      }
      server {
          listen 443 ssl http2;
          server_name ${domain_name};
          ssl_certificate /etc/letsencrypt/live/${domain_name}/fullchain.pem;
          ssl_certificate_key /etc/letsencrypt/live/${domain_name}/privkey.pem;
          ssl_protocols TLSv1.2 TLSv1.3;
          ssl_ciphers HIGH:!aNULL:!MD5;
          ssl_prefer_server_ciphers on;
          location / {
              proxy_pass http://localhost:3000;
              proxy_http_version 1.1;
              proxy_set_header Upgrade $http_upgrade;
              proxy_set_header Connection 'upgrade';
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
              proxy_cache_bypass $http_upgrade;
          }
      }

  - path: /opt/app/docker-compose.yml
    content: |
      services:
        app:
          image: ghcr.io/${github_repo}:latest
          restart: unless-stopped
          ports:
            - "3000:3000"
          environment:
            PORT: 3000
            DB_HOST: postgres
            DB_PORT: 5432
            DB_NAME: appdb
            DB_USER: appuser
            DB_PASSWORD: ${db_password}
            NODE_ENV: production
          depends_on:
            postgres:
              condition: service_healthy
          networks:
            - app_network
        postgres:
          image: postgres:16-alpine
          container_name: postgres
          restart: unless-stopped
          environment:
            POSTGRES_DB: appdb
            POSTGRES_USER: appuser
            POSTGRES_PASSWORD: ${db_password}
          volumes:
            - postgres_data:/var/lib/postgresql/data
          healthcheck:
            test: ["CMD-SHELL", "pg_isready -U appuser"]
            interval: 5s
            timeout: 5s
            retries: 5
          networks:
            - app_network
      volumes:
        postgres_data:
      networks:
        app_network:
          driver: bridge  

  - path: /usr/local/bin/setup-ssl.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e
      DOMAIN="${domain_name}"
      EMAIL="${letsencrypt_email}"
      # Wait for DNS
      until host $DOMAIN | grep "has address"; do
        echo "Waiting for DNS..."
        sleep 10
      done
      # CHANGE: Use webroot mode (uses port 80 while Nginx is running)
      certbot certonly --webroot -w /var/www/html \
        --non-interactive --agree-tos --email $EMAIL -d $DOMAIN
      if [ -f "/etc/letsencrypt/live/$DOMAIN/fullchain.pem" ]; then
        cp /etc/nginx/sites-available/app.final /etc/nginx/sites-available/app
        systemctl reload nginx
      fi

runcmd:
# 1. Prepare Webroot for SSL
  - mkdir -p /var/www/html/.well-known/acme-challenge
  - chown -R www-data:www-data /var/www/html
  - chmod -R 755 /var/www/html

  # 2. Install Docker using the official convenience script (More reliable in cloud-init)
  - curl -fsSL https://get.docker.com -o get-docker.sh
  - sh get-docker.sh
  - systemctl enable --now docker

  # 3. Setup App Directory
  - mkdir -p /opt/app
  - chown -R ubuntu:ubuntu /opt/app

  # 4. Configure Nginx
  - ln -sf /etc/nginx/sites-available/app /etc/nginx/sites-enabled/app
  - rm -f /etc/nginx/sites-enabled/default
  - systemctl restart nginx

  # 5. Run SSL Setup
  - /usr/local/bin/setup-ssl.sh >> /var/log/cloud-init-output.log 2>&1

  # 6. Start the App (Using full path to ensure it's found)
  - cd /opt/app && /usr/bin/docker compose pull >> /var/log/cloud-init-output.log 2>&1
  - cd /opt/app && /usr/bin/docker compose up -d >> /var/log/cloud-init-output.log 2>&1
  - chown -R ubuntu:ubuntu /opt/app